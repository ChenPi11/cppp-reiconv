/**
 * @file cppp/reiconv.hpp
 * @author ChenPi11
 * @brief C++ Plus cppp-reiconv package.
 * @version 3.0.0
 * @date 2023-10-04
 * @copyright Copyright (C) 1999-2023 Free Software Foundation, Inc.
 */
/* Copyright (C) 1999-2023 Free Software Foundation, Inc.
   This file is part of the cppp-reiconv library.

   The cppp-reiconv library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either version 3
   of the License, or (at your option) any later version.

   The cppp-reiconv library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the cppp-reiconv library; see the file COPYING.
   If not, see <https://www.gnu.org/licenses/>.  */

/* When installed, this file is called "cppp/reiconv.hpp". */

#pragma once

#include <stddef.h>

#if _MSC_VER >= 1600 
/* Use UTF-8 to decode this file. */
#pragma execution_character_set("utf-8")
#endif

extern "C++"
{
    namespace cppp
    {
    namespace base
    {
    namespace reiconv
    {
    /**
     * @brief Version infomation. (major<<8) + minor
     */
    extern @DLL_VARIABLE@ int reiconv_version;
    
    /**
     * @brief Converts an entire string from one encoding to another,
     * and supports autodetect encodings on input.
     *
     * @note Converts a memory region given in encoding FROMCODE to a new memory
     * region in encoding TOCODE. FROMCODE and TOCODE are as for iconv_open(3),
     * except that FROMCODE may be one of the values.
     *
     * @note "autodetect_utf8"          supports ISO-8859-1 and UTF-8
     * @note "autodetect_jp"            supports EUC-JP, ISO-2022-JP-2 and SHIFT_JIS
     * @note "autodetect_kr"            supports EUC-KR and ISO-2022-KR
     * @note The input is in the memory region between start (inclusive) and end
     * (exclusive). If resultp is not NULL, the output string is stored in
     * *resultp; malloc/realloc is used to allocate the result.
     *
     * @note This function does not treat zero characters specially.
     * @param tocode Target encoding.
     * @param fromcode From encoding.
     * @param start Source string start pointer.
     * @param end Source string end pointer.
     * @param resultp Result memory pointer.
     * @param lengthp Pointer to a variable that stores the length of the result.
     * @return Return 0 if successful, otherwise return errno and errno set. Particular errno values: EILSEQ and ENOMEM.
     *
     * @example
     *   const char* s = ...;
     *   char* result = NULL;
     *   if (convert("UCS-4-INTERNAL", "GBK",
     *                    s, strlen(s)+1, &result, NULL) != 0)
     *   perror("convert");
     *
     */
    extern @DLL_VARIABLE@ int convert(const char* tocode, const char* fromcode, const char* start,
                                            size_t inlength, char** resultp, size_t* lengthp);

    /**
     * @brief Converts an entire string from one encoding to another.
     * @note This function does not treat zero characters specially.
     * @param tocode_cp Target encoding codepage.
     * @param fromcode_cp From encoding codepage.
     * @param start Source string start pointer.
     * @param end Source string end pointer.
     * @param resultp Result memory pointer.
     * @param lengthp Pointer to a variable that stores the length of the result.
     * @param strict Strict mode, if false, will ignore the invalid characters.
     * @return Return 0 if successful, otherwise return errno and errno set. Particular errno values: EILSEQ and ENOMEM.
     *
     * @example
     *   const char* s = ...;
     *   char* result = NULL;
     *   if (convert(65001, 936,
     *                    s, strlen(s)+1, &result, NULL) != 0)
     *   perror("convert");
     *
     */
    extern @DLL_VARIABLE@ int convert(int tocode_cp, int fromcode_cp, const char* start,
                                            size_t inlength, char** resultp, size_t* lengthp, bool strict=true);

    } // namespace reiconv
    } // namespace base
    } // namespace cppp
}
