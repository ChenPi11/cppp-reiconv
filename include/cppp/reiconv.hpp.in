/* Copyright (C) 1999-2023 Free Software Foundation, Inc.
   This file is part of the cppp-reiconv library.

   The cppp-reiconv library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either version 2.1
   of the License, or (at your option) any later version.

   The cppp-reiconv library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the cppp-reiconv library; see the file COPYING.
   If not, see <https://www.gnu.org/licenses/>.  */

/* When installed, this file is called "cppp/reiconv.hpp". */

#ifndef _CPPP_REICONV_HPP
#define _CPPP_REICONV_HPP

#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include <stddef.h>
#include <errno.h>
#include <wchar.h>

extern "C++"
{
   namespace cppp{namespace base{namespace reiconv
   {
      extern @DLL_VARIABLE@ int reiconv_version; /* Likewise */

      /* Define iconv_t ourselves. */
      #undef iconv_t
      typedef void* iconv_t;

      /* Allocates descriptor for code conversion from encoding ‘fromcode’ to
         encoding ‘tocode’. */
      extern @DLL_VARIABLE@ iconv_t iconv_open (const char* tocode, const char* fromcode);

      /* Converts, using conversion descriptor ‘cd’, at most ‘*inbytesleft’ bytes
         starting at ‘*inbuf’, writing at most ‘*outbytesleft’ bytes starting at
         ‘*outbuf’.
         Decrements ‘*inbytesleft’ and increments ‘*inbuf’ by the same amount.
         Decrements ‘*outbytesleft’ and increments ‘*outbuf’ by the same amount. */
      extern @DLL_VARIABLE@ size_t iconv (iconv_t cd, char* * inbuf, size_t *inbytesleft, char* * outbuf, size_t *outbytesleft);

      /* Frees resources allocated for conversion descriptor ‘cd’. */
      extern @DLL_VARIABLE@ int iconv_close (iconv_t cd);

      /* A type that holds all memory needed by a conversion descriptor.
         A pointer to such an object can be used as an iconv_t. */
      typedef struct
      {
         void* dummy1[28];
         mbstate_t dummy2;
      } iconv_allocation_t;

      /* Allocates descriptor for code conversion from encoding ‘fromcode’ to
         encoding ‘tocode’ into preallocated memory. Returns an error indicator
         (0 or -1 with errno set). */
      extern @DLL_VARIABLE@ int iconv_open_into (const char* tocode, const char* fromcode,
                                 iconv_allocation_t* resultp);

      /* Control of attributes. */
      extern @DLL_VARIABLE@ int iconvctl (iconv_t cd, int request, void* argument);

      /* Hook performed after every successful conversion of a Unicode character. */
      typedef void (*iconv_unicode_char_hook) (unsigned int uc, void* data);
      /* Hook performed after every successful conversion of a wide character. */
      typedef void (*iconv_wide_char_hook) (wchar_t wc, void* data);
      /* Set of hooks. */
      struct iconv_hooks
      {
         iconv_unicode_char_hook uc_hook;
         iconv_wide_char_hook wc_hook;
         void* data;
      };

      /* Fallback function.  Invoked when a small number of bytes could not be
         converted to a Unicode character.  This function should process all
         bytes from inbuf and may produce replacement Unicode characters by calling
         the write_replacement callback repeatedly.  */
      typedef void (*iconv_unicode_mb_to_uc_fallback)
                  (const char* inbuf, size_t inbufsize,
                  void (*write_replacement) (const unsigned int *buf, size_t buflen,
                                             void* callback_arg),
                  void* callback_arg,
                  void* data);
      
      /* Fallback function.  Invoked when a Unicode character could not be converted
         to the target encoding.  This function should process the character and
         may produce replacement bytes (in the target encoding) by calling the
         write_replacement callback repeatedly.  */
      typedef void (*iconv_unicode_uc_to_mb_fallback)
                  (unsigned int code,
                  void (*write_replacement) (const char *buf, size_t buflen,
                                             void* callback_arg),
                  void* callback_arg,
                  void* data);

      /* Fallback function.  Invoked when a number of bytes could not be converted to
         a wide character.  This function should process all bytes from inbuf and may
         produce replacement wide characters by calling the write_replacement
         callback repeatedly.  */
      typedef void (*iconv_wchar_mb_to_wc_fallback)
                  (const char* inbuf, size_t inbufsize,
                  void (*write_replacement) (const wchar_t *buf, size_t buflen,
                                             void* callback_arg),
                  void* callback_arg,
                  void* data);
      
      /* Fallback function.  Invoked when a wide character could not be converted to
         the target encoding.  This function should process the character and may
         produce replacement bytes (in the target encoding) by calling the
         write_replacement callback repeatedly.  */
      typedef void (*iconv_wchar_wc_to_mb_fallback)
                  (wchar_t code,
                  void (*write_replacement) (const char *buf, size_t buflen,
                                             void* callback_arg),
                  void* callback_arg,
                  void* data);

      /* Set of fallbacks. */
      struct iconv_fallbacks
      {
         iconv_unicode_mb_to_uc_fallback mb_to_uc_fallback;
         iconv_unicode_uc_to_mb_fallback uc_to_mb_fallback;
         iconv_wchar_mb_to_wc_fallback mb_to_wc_fallback;
         iconv_wchar_wc_to_mb_fallback wc_to_mb_fallback;
         void* data;
      };

      /* Surfaces.
         The concept of surfaces is described in the 'recode' manual.  */
      constexpr int ICONV_SURFACE_NONE = 0;
      /* In EBCDIC encodings, 0x15 (which encodes the "newline function", see the
         Unicode standard, chapter 5) maps to U+000A instead of U+0085.  This is
         for interoperability with C programs and Unix environments on z/OS.  */
      constexpr int ICONV_SURFACE_EBCDIC_ZOS_UNIX = 1;////////////

      /* Requests for iconvctl. */
      constexpr int  ICONV_TRIVIALP = 0;  /* int *argument */
      constexpr int  ICONV_GET_DISCARD_ILSEQ = 3;  /* int *argument */
      constexpr int  ICONV_SET_DISCARD_ILSEQ = 4;  /* const int *argument */
      constexpr int  ICONV_SET_HOOKS = 5;  /* const struct iconv_hooks *argument */
      constexpr int  ICONV_SET_FALLBACKS = 6;  /* const struct iconv_fallbacks *argument */
      constexpr int  ICONV_GET_FROM_SURFACE = 7;  /* unsigned int *argument */
      constexpr int  ICONV_SET_FROM_SURFACE = 8;  /* const unsigned int *argument */
      constexpr int  ICONV_GET_TO_SURFACE = 9;  /* unsigned int *argument */
      constexpr int  ICONV_SET_TO_SURFACE = 10;  /* const unsigned int *argument */

      /* Listing of locale independent encodings. */
      extern @DLL_VARIABLE@ void iconvlist (int (*do_one) (unsigned int namescount,
                                          const char * const * names,
                                          void* data),
                           void* data);

      /* Canonicalize an encoding name.
         The result is either a canonical encoding name, or name itself. */
      extern @DLL_VARIABLE@ const char * iconv_canonicalize (const char * name);

      /*
      * This C function converts an entire string from one encoding to another,
      * using iconv. Easier to use than iconv() itself, and supports autodetect
      * encodings on input.
      *
      *   int iconv_string (const char* tocode, const char* fromcode,
      *                     const char* start, const char* end,
      *                     char** resultp, size_t* lengthp)
      *
      * Converts a memory region given in encoding FROMCODE to a new memory
      * region in encoding TOCODE. FROMCODE and TOCODE are as for iconv_open(3),
      * except that FROMCODE may be one of the values
      *    "autodetect_utf8"          supports ISO-8859-1 and UTF-8
      *    "autodetect_jp"            supports EUC-JP, ISO-2022-JP-2 and SHIFT_JIS
      *    "autodetect_kr"            supports EUC-KR and ISO-2022-KR
      * The input is in the memory region between start (inclusive) and end
      * (exclusive). If resultp is not NULL, the output string is stored in
      * *resultp; malloc/realloc is used to allocate the result.
      *
      * This function does not treat zero characters specially.
      *
      * Return value: 0 if successful, otherwise -1 and errno set. Particular
      * errno values: EILSEQ and ENOMEM.
      *
      * Example:
      *   const char* s = ...;
      *   char* result = NULL;
      *   if (iconv_string("UCS-4-INTERNAL", "autodetect_utf8",
      *                    s, s+strlen(s)+1, &result, NULL) < 0)
      *     perror("iconv_string");
      *
      */
      extern @DLL_VARIABLE@ int iconv_string (const char* tocode, const char* fromcode, const char* start, const char* end, char** resultp, size_t* lengthp);
      
   }}}
}

#endif /* _CPPP_REICONV_HPP */
