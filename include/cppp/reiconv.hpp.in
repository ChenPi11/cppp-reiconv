/**
 * @file cppp/reiconv.hpp
 * @author ChenPi11
 * @brief C+++ cppp-reiconv package.
 * @version 3.0.0
 * @date 2024-7-27
 * @copyright Copyright (C) 1999-2023 Free Software Foundation, Inc.
 */
/* Copyright (C) 1999-2023 Free Software Foundation, Inc.
   This file is part of the cppp-reiconv library.

   The cppp-reiconv library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either version 3
   of the License, or (at your option) any later version.

   The cppp-reiconv library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the cppp-reiconv library; see the file LICENSE.
   If not, see <https://www.gnu.org/licenses/>.  */

/* When installed, this file is called "cppp/reiconv.hpp". */

#pragma once

#include <cppp/encodings/reiconv.hpp>

#include <cstddef>
#include <cstring>
#include <string>

#define _CPPP_API

#ifndef _CPPP_API
#define _CPPP_API @CPPP_API@
#endif

#if _MSC_VER >= 1600
#pragma execution_character_set("utf-8")
#endif

namespace cppp::base::reiconv
{
    using cppp::base::encoding::Encodings;

    template <typename ByteType>
    struct BasicBuffer
    {
        /**
         * @brief Buffer pointer.
         */
        ByteType *buffer;

        /**
         * @brief Buffer size.
         */
        std::size_t length;

        /**
         * @brief Construct a buffer.
         */
        BasicBuffer(ByteType *buffer, std::size_t length) : buffer(buffer), length(length) {}

        /**
         * @brief Construct a buffer from a string.
         */
        BasicBuffer(const std::string &str) : buffer(reinterpret_cast<ByteType*>(str.data())), length(str.size()) {}

        /**
         * @brief Construct a buffer from a string.
         */
        BasicBuffer(const char* str) : buffer(reinterpret_cast<ByteType*>(str)), length(std::strlen(str)) {}
    };

    /**
     * @brief Buffer for input.
     */
    using InputBuffer = BasicBuffer<const std::byte>;

    /**
     * @brief Buffer for output.
     */
    using OutputBuffer = BasicBuffer<std::byte>;

    /**
     * @brief Encoding class.
     */
    class Encoding
    {
    private:
        /**
         * @brief Encoding index. This is the internal representation of the encoding.
         */
        int _index;

    public:

        /**
         * @brief Find the encoding by name. IANA names are recommended.
         * @throw std::invalid_argument if the encoding is not found.
         */
        _CPPP_API Encoding(const char* const name);

        /**
         * @brief Find the encoding by name. IANA names are recommended.
         * @throw std::invalid_argument if the encoding is not found.
         */
        _CPPP_API Encoding(const std::string& name) : Encoding(name.c_str()) {}

        /**
         * @brief Find the encoding by codepage. Supports Windows and z/OS codepages.
         * @throw std::invalid_argument if the encoding is not found.
         */
        _CPPP_API Encoding(const int codepage);

        /**
         * @brief Find the encoding by index.
         * @throw std::invalid_argument if the encoding is not found.
         */
        constexpr Encoding(const Encodings index) : _index(static_cast<int>(index)) {}

        /**
         * @brief Get the encoding index.
         */
        operator int() const noexcept { return _index; }

        /**
         * @brief Get the encoding name.
         */
        bool operator==(const Encoding other) const noexcept { return _index == other._index; }
    };

    /**
     * @brief Version information.
     */
    struct VersionInfo
    {
        /**
         * @brief Major version.
         */
        int major;

        /**
         * @brief Minor version.
         */
        int minor;

        /**
         * @brief Patch version.
         */
        int patch;
    };

    /**
     * @brief Version infomation.
     */
    extern _CPPP_API VersionInfo version;

    /**
     * @brief Converts an string from one encoding to another, supports encodings autodetecting.
     *
     * @note Converts a memory region given in encoding FROMCODE to a new memory
     * region in encoding TOCODE. FROMCODE and TOCODE are as for iconv_open(3), we don't support
     * '//IGNORE' and '//TRANSLIT'.
     * malloc/realloc is used to allocate the result.
     *
     * @note This function does not treat zero characters specially.
     * @param from The input buffer encoding.
     * @param to The output buffer encoding.
     * @param input Input buffer.
     * @param strict If false. We will ignore all conversion errors. Same as iconv(3) '//IGNORE'.
     * @return Return the output buffer.
     * @throw std::system_error if an error occurs.
     */
    extern _CPPP_API OutputBuffer convert(Encoding from, Encoding to, InputBuffer input, bool strict = true);

} // namespace cppp::base::reiconv
